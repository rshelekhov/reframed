// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: auth.sql

package postgres

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const addDevice = `-- name: AddDevice :exec

INSERT INTO user_devices (id, user_id, user_agent, ip, detached, latest_login_at)
VALUES ($1, $2, $3, $4, $5, $6)
`

type AddDeviceParams struct {
	ID            string             `db:"id"`
	UserID        string             `db:"user_id"`
	UserAgent     string             `db:"user_agent"`
	Ip            string             `db:"ip"`
	Detached      bool               `db:"detached"`
	LatestLoginAt pgtype.Timestamptz `db:"latest_login_at"`
}

// SQL queries for user sessions
func (q *Queries) AddDevice(ctx context.Context, arg AddDeviceParams) error {
	_, err := q.db.Exec(ctx, addDevice,
		arg.ID,
		arg.UserID,
		arg.UserAgent,
		arg.Ip,
		arg.Detached,
		arg.LatestLoginAt,
	)
	return err
}

const deleteRefreshToken = `-- name: DeleteRefreshToken :exec
DELETE FROM refresh_sessions
WHERE refresh_token = $1
`

func (q *Queries) DeleteRefreshToken(ctx context.Context, refreshToken string) error {
	_, err := q.db.Exec(ctx, deleteRefreshToken, refreshToken)
	return err
}

const deleteSession = `-- name: DeleteSession :exec
DELETE FROM refresh_sessions
WHERE user_id = $1
  AND device_id = $2
`

type DeleteSessionParams struct {
	UserID   pgtype.Text `db:"user_id"`
	DeviceID string      `db:"device_id"`
}

func (q *Queries) DeleteSession(ctx context.Context, arg DeleteSessionParams) error {
	_, err := q.db.Exec(ctx, deleteSession, arg.UserID, arg.DeviceID)
	return err
}

const deleteUser = `-- name: DeleteUser :exec
UPDATE users
SET deleted_at = $1
WHERE id = $2
  AND deleted_at IS NULL
`

type DeleteUserParams struct {
	DeletedAt pgtype.Timestamptz `db:"deleted_at"`
	ID        string             `db:"id"`
}

func (q *Queries) DeleteUser(ctx context.Context, arg DeleteUserParams) error {
	_, err := q.db.Exec(ctx, deleteUser, arg.DeletedAt, arg.ID)
	return err
}

const getSessionByRefreshToken = `-- name: GetSessionByRefreshToken :one
SELECT user_id, device_id, last_visit_at, expires_at
FROM refresh_sessions
WHERE refresh_token = $1
`

type GetSessionByRefreshTokenRow struct {
	UserID      pgtype.Text        `db:"user_id"`
	DeviceID    string             `db:"device_id"`
	LastVisitAt pgtype.Timestamptz `db:"last_visit_at"`
	ExpiresAt   pgtype.Timestamptz `db:"expires_at"`
}

func (q *Queries) GetSessionByRefreshToken(ctx context.Context, refreshToken string) (GetSessionByRefreshTokenRow, error) {
	row := q.db.QueryRow(ctx, getSessionByRefreshToken, refreshToken)
	var i GetSessionByRefreshTokenRow
	err := row.Scan(
		&i.UserID,
		&i.DeviceID,
		&i.LastVisitAt,
		&i.ExpiresAt,
	)
	return i, err
}

const getUserByEmail = `-- name: GetUserByEmail :one
SELECT id, email, updated_at
FROM users
WHERE email = $1
  AND deleted_at IS NULL
`

type GetUserByEmailRow struct {
	ID        string             `db:"id"`
	Email     string             `db:"email"`
	UpdatedAt pgtype.Timestamptz `db:"updated_at"`
}

func (q *Queries) GetUserByEmail(ctx context.Context, email string) (GetUserByEmailRow, error) {
	row := q.db.QueryRow(ctx, getUserByEmail, email)
	var i GetUserByEmailRow
	err := row.Scan(&i.ID, &i.Email, &i.UpdatedAt)
	return i, err
}

const getUserByID = `-- name: GetUserByID :one
SELECT id, email, updated_at
FROM users
WHERE id = $1
  AND deleted_at IS NULL
`

type GetUserByIDRow struct {
	ID        string             `db:"id"`
	Email     string             `db:"email"`
	UpdatedAt pgtype.Timestamptz `db:"updated_at"`
}

func (q *Queries) GetUserByID(ctx context.Context, id string) (GetUserByIDRow, error) {
	row := q.db.QueryRow(ctx, getUserByID, id)
	var i GetUserByIDRow
	err := row.Scan(&i.ID, &i.Email, &i.UpdatedAt)
	return i, err
}

const getUserData = `-- name: GetUserData :one
SELECT id, email, password_hash, updated_at
FROM users
WHERE id = $1
  AND deleted_at IS NULL
`

type GetUserDataRow struct {
	ID           string             `db:"id"`
	Email        string             `db:"email"`
	PasswordHash string             `db:"password_hash"`
	UpdatedAt    pgtype.Timestamptz `db:"updated_at"`
}

func (q *Queries) GetUserData(ctx context.Context, id string) (GetUserDataRow, error) {
	row := q.db.QueryRow(ctx, getUserData, id)
	var i GetUserDataRow
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.PasswordHash,
		&i.UpdatedAt,
	)
	return i, err
}

const getUserDeviceID = `-- name: GetUserDeviceID :exec
SELECT id
FROM user_devices
WHERE user_id = $1
  AND user_agent = $2
  AND detached = FALSE
`

type GetUserDeviceIDParams struct {
	UserID    string `db:"user_id"`
	UserAgent string `db:"user_agent"`
}

func (q *Queries) GetUserDeviceID(ctx context.Context, arg GetUserDeviceIDParams) error {
	_, err := q.db.Exec(ctx, getUserDeviceID, arg.UserID, arg.UserAgent)
	return err
}

const getUserID = `-- name: GetUserID :one
SELECT id
FROM users
WHERE email = $1
  AND deleted_at IS NULL
`

func (q *Queries) GetUserID(ctx context.Context, email string) (string, error) {
	row := q.db.QueryRow(ctx, getUserID, email)
	var id string
	err := row.Scan(&id)
	return id, err
}

const getUserStatus = `-- name: GetUserStatus :one

SELECT CASE
WHEN EXISTS(
    SELECT 1
    FROM users
    WHERE users.email = $1
      AND deleted_at IS NULL FOR UPDATE
) THEN 'active'
WHEN EXISTS(
    SELECT 1
    FROM users
    WHERE users.email = $1
      AND deleted_at IS NOT NULL FOR UPDATE
    ) THEN 'soft_deleted'
ELSE 'not_found' END AS status
`

// SQL queries for user management
func (q *Queries) GetUserStatus(ctx context.Context, email string) (string, error) {
	row := q.db.QueryRow(ctx, getUserStatus, email)
	var status string
	err := row.Scan(&status)
	return status, err
}

const insertUser = `-- name: InsertUser :exec
INSERT INTO users (id, email, password_hash, updated_at)
VALUES ($1, $2, $3, $4)
`

type InsertUserParams struct {
	ID           string             `db:"id"`
	Email        string             `db:"email"`
	PasswordHash string             `db:"password_hash"`
	UpdatedAt    pgtype.Timestamptz `db:"updated_at"`
}

func (q *Queries) InsertUser(ctx context.Context, arg InsertUserParams) error {
	_, err := q.db.Exec(ctx, insertUser,
		arg.ID,
		arg.Email,
		arg.PasswordHash,
		arg.UpdatedAt,
	)
	return err
}

const saveSession = `-- name: SaveSession :exec
INSERT INTO refresh_sessions (user_id, device_id, refresh_token, last_visit_at, expires_at)
VALUES ($1, $2, $3, $4, $5)
`

type SaveSessionParams struct {
	UserID       pgtype.Text        `db:"user_id"`
	DeviceID     string             `db:"device_id"`
	RefreshToken string             `db:"refresh_token"`
	LastVisitAt  pgtype.Timestamptz `db:"last_visit_at"`
	ExpiresAt    pgtype.Timestamptz `db:"expires_at"`
}

func (q *Queries) SaveSession(ctx context.Context, arg SaveSessionParams) error {
	_, err := q.db.Exec(ctx, saveSession,
		arg.UserID,
		arg.DeviceID,
		arg.RefreshToken,
		arg.LastVisitAt,
		arg.ExpiresAt,
	)
	return err
}

const setDeletedUserAtNull = `-- name: SetDeletedUserAtNull :exec
UPDATE users
SET deleted_at = NULL
WHERE email = $1
`

func (q *Queries) SetDeletedUserAtNull(ctx context.Context, email string) error {
	_, err := q.db.Exec(ctx, setDeletedUserAtNull, email)
	return err
}

const updateLatestLoginAt = `-- name: UpdateLatestLoginAt :exec
UPDATE user_devices
SET latest_login_at = $1
WHERE id = $2
`

type UpdateLatestLoginAtParams struct {
	LatestLoginAt pgtype.Timestamptz `db:"latest_login_at"`
	ID            string             `db:"id"`
}

func (q *Queries) UpdateLatestLoginAt(ctx context.Context, arg UpdateLatestLoginAtParams) error {
	_, err := q.db.Exec(ctx, updateLatestLoginAt, arg.LatestLoginAt, arg.ID)
	return err
}
